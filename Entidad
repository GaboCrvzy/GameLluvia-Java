package com.tuempresa.gamelluvia;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;

public abstract class Entidad {
    private final Texture textura;
    private final Vector2 posicion;
    private final Vector2 tam;

    // para evitar crear un Rectangle en cada frame
    private final Rectangle bounds = new Rectangle();

    protected Entidad(Texture textura, float x, float y, float w, float h) {
        if (textura == null) throw new IllegalArgumentException("La textura no puede ser null");
        if (w <= 0 || h <= 0) throw new IllegalArgumentException("El tamaño (w,h) debe ser positivo");

        this.textura  = textura;
        this.posicion = new Vector2(x, y);
        this.tam      = new Vector2(w, h);
    }

    // TEMPLATE METHOD
    // Define el algoritmo general 
    public final void update(float dt) 
    {
        mover(dt);         // comportamiento específico 
        aplicarLimites();  // comportamiento común
        postUpdate(dt);    
    }

    // Cada subclase DEBE implementar
    protected abstract void mover(float dt);

    // Paso común para todas las entidades
    protected void aplicarLimites()
    {
        setXLimites(posicion.x, ConstantesJuego.ANCHO_MUNDO);
        setYLimites(posicion.y, ConstantesJuego.ALTO_MUNDO);
    }

    protected void postUpdate(float dt) {}

    // Dibuja la textura con el batch (pincel) de LibGDX
    public void render(SpriteBatch batch) {
        batch.draw(textura, posicion.x, posicion.y, tam.x, tam.y);
    }

    // Devuelve los límites para colisiones 
    public Rectangle getBounds() {
        return bounds.set(posicion.x, posicion.y, tam.x, tam.y);
    }

    // Liberar la memoria de la textura cuando no se use 
    public void dispose() { textura.dispose(); }

    // GETTERS
    public float getX()      { return posicion.x; }
    public float getY()      { return posicion.y; }
    public float getWidth()  { return tam.x; }
    public float getHeight() { return tam.y; }

    public Vector2 getPosicion() { return posicion; }
    public Vector2 getTam()      { return tam; }

    // SETTERS
    public void setX(float x) { this.posicion.x = x; }
    public void setY(float y) { this.posicion.y = y; }

    // Cambiar tamaño con validación
    public void setSize(float w, float h) {
        if (w <= 0 || h <= 0) throw new IllegalArgumentException("El tamaño debe ser positivo");
        this.tam.set(w, h);
    }

    // Setters con limites del mundo 
    public void setXLimites(float x, float anchoMundo) {
        this.posicion.x = MathUtils.clamp(x, 0f, anchoMundo - tam.x);
    }

    public void setYLimites(float y, float altoMundo) {
        this.posicion.y = MathUtils.clamp(y, 0f, altoMundo - tam.y);
    }
}
