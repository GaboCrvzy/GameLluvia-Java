package com.tuempresa.gamelluvia;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;

public abstract class Entidad {
    private final Texture textura;
    private final Vector2 posicion;
    private final Vector2 tam;

    // para evitar crear un Rectangle en cada frame
    private final Rectangle bounds = new Rectangle();

    protected Entidad(Texture textura, float x, float y, float w, float h) {
        if (textura == null) throw new IllegalArgumentException("La textura no puede ser null");
        if (w <= 0 || h <= 0) throw new IllegalArgumentException("El tamaño (w,h) debe ser positivo");

        this.textura  = textura;
        this.posicion = new Vector2(x, y);
        this.tam      = new Vector2(w, h);
    }

    // Actualiza la lógica del juego en cada frame, dt = delta time 
    public abstract void update(float dt);

    // Dibuja la textura con el batch (pincel) de LibGDX
    public void render(SpriteBatch batch) {
        batch.draw(textura, posicion.x, posicion.y, tam.x, tam.y);
    }

    // Devuelve los límites para colisiones 
    public Rectangle getBounds() {
        return bounds.set(posicion.x, posicion.y, tam.x, tam.y);
    }

    // Liberar la memoria de la textura cuando no se use 
    public void dispose() {textura.dispose();}

    // GETTERS
    public float getX()      { return posicion.x; }
    public float getY()      { return posicion.y; }
    public float getWidth()  { return tam.x; }
    public float getHeight() { return tam.y; }

    // SETTERS
    public void setX(float x) { this.posicion.x = x; }
    public void setY(float y) { this.posicion.y = y; }

    // Cambiar tamaño con validación
    public void setSize(float w, float h) 
    {
        if (w <= 0 || h <= 0) throw new IllegalArgumentException("El tamaño debe ser positivo");
        this.tam.set(w, h);
    }

    // Setters con limites del mundo (clamp)
    public void setXLimites(float x, float anchoMundo) 
    {
    	this.posicion.x = MathUtils.clamp(x, 0f, ConstantesJuego.ANCHO_MUNDO - tam.x);
    }

    public void setYLimites(float y, float altoMundo) 
    {
    	this.posicion.y = MathUtils.clamp(y, 0f, ConstantesJuego.ALTO_MUNDO - tam.y);
    }
    
}
